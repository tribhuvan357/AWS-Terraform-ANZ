<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<  AWS Terraform Notes >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
aws configure
where terraform
choco upgrade terraform -y  => Run as a admin from CMD/Powershell
terraform version
terraform -version


Terraform Config
. It uses .tf extension
. Format is HCL (Hashicorp Config Language)
· Declarative Language
· State Management


=> AWS EC2 with terraform

main.tf
variables.tf
provider.tf
resource.tf
terraform.tfstate
terraform.tfstate.backup
.terraform.lock.hcl
.terraform.tfstate.lock.info
{"ID":"48a0ab83-7e31-6c11-4b72-0e88e2d354d9","Operation":"OperationTypeApply","Info":"","Who":"Tribhuvan_PC\\Tribhuvan@Tribhuvan_PC","Version":"1.12.2","Created":"2025-08-10T07:57:59.3343403Z","Path":"terraform.tfstate"}
.terraform\providers\registry.terraform.io\hashicorp\aws\6.7.0\windows_amd64 => LICENSE and terraform-provider-aws_v6.7.0_x5


=> Terraform execution command

terraform init
terraform plan    => if we made changes we need to plan everytime else it will execute old/previous code
terraform apply
terraform apply -auto-approve
terraform destroy
terraform destroy -auto-approve
terraform validate
terraform fmt     => For the coorect formate


=> Github repo repository name

tribhuvan357/AWS-Terraform-ANZ 
https://github.com/tribhuvan357/AWS-Terraform-ANZ

----------------------------------------------------------------------------------------------------------------------------------------------

<<<<<<<<<< Terraform Resource >>>>>>>>>>

Definition: A resource block creates and manages infrastructure in AWS (or any provider).

Use Case: When you want Terraform to provision, update, or delete something.

Example: Creating an EC2 instance.

resource "aws_instance" "web" {
  ami           = "ami-0abcdef1234567890"
  instance_type = "t2.micro"
}


👉 This creates an EC2 instance. If you run terraform destroy, Terraform will also delete it.

<<<<<<<<<< Terraform Data Source >>>>>>>>>>>>

Definition: A data block reads and fetches existing information from the provider without creating anything.

Use Case: When you need to use already existing resources (not managed by Terraform).

Example: Fetching the latest Amazon Linux AMI ID.

data "aws_ami" "amazon_linux" {
  most_recent = true
  owners      = ["amazon"]

  filter {
    name   = "name"
    values = ["amzn2-ami-hvm-*-x86_64-gp2"]
  }
}


👉 This does not create an AMI — it only looks up the latest AMI ID from AWS so you can use it in your resources:

resource "aws_instance" "web" {
  ami           = data.aws_ami.amazon_linux.id
  instance_type = "t2.micro"
}

----------------------------------------------------------------------------------------------------------------------------------------------

vol-0cdabccda027cb76e /dev/xvda 20  => EC2 storage console details

[root@ip-172-31-14-57 ~]# df -hT    => EC2 linux server OS level storage details
Filesystem       Type      Size  Used Avail Use% Mounted on
devtmpfs         devtmpfs  4.0M     0  4.0M   0% /dev
tmpfs            tmpfs     453M     0  453M   0% /dev/shm
tmpfs            tmpfs     181M  436K  181M   1% /run
/dev/nvme0n1p1   xfs        20G  1.7G   19G   9% /
tmpfs            tmpfs     453M     0  453M   0% /tmp
/dev/nvme0n1p128 vfat       10M  1.3M  8.7M  13% /boot/efi
tmpfs            tmpfs      91M     0   91M   0% /run/user/1000
[root@ip-172-31-14-57 ~]#
[root@ip-172-31-14-57 ~]# lsblk
NAME          MAJ:MIN RM SIZE RO TYPE MOUNTPOINTS
nvme0n1       259:0    0  20G  0 disk
├─nvme0n1p1   259:1    0  20G  0 part /
├─nvme0n1p127 259:2    0   1M  0 part
└─nvme0n1p128 259:3    0  10M  0 part /boot/efi
[root@ip-172-31-14-57 ~]#
[root@ip-172-31-14-57 ~]#
-----------------------------------------------------------------------------------------------------------

=> Resource Change

We can change the AMI ID/image and instance type to the current/prevoius terraform file and do terraform apply which will destroy the current ec2 server and make the ec2 server with given details

=> Resource Destroy 

=> More about TF Config

State Management

The state file (terraform.tfstate) maintains a detailed record of the current state of managed resources

This state file can be stored locally or remotely, with remote storage options enabling collaboration by sharing the state across teams and environments.

=> Terraform Variable

Input variables => are like function arguments.
Output values   => are like function return values.
Local values    => are like a function's temporary local variables.

=> Terraform Output
To print the public/private, ami id and provisioning server aws instance id etc in terraform cli 

=> AWS Resource S3 bucket and Ramdom Provider(for bucket name)
AWS S3 (Amazon Simple Storage Service) is a scalable, high-speed, web-based cloud storage service designed for online backup and archiving of data and applications.


=============================================================================================================================
<<<<<< Github Repo >>>>>

Note:- always first create repo manually on github portal and then follow the below steps

git init
git remote add origin https://github.com/tribhuvan357/AWS-Terraform-ANZ.git
git pull origin master
git status
git commit -m "all ANZ AWS terraform pracs"
git status
pwd
git add .
git status
git commit -m "all ANZ AWS terraform pracs"
git status
git push -u origin master



=============================================================================================================================

=> Remote State Management
Done => github updated


=> Project static website host
Done => github updated


=> AWS VPC via Terraform
Done => AWS Manual Lab

=> VPC Creation Terraform Config

Exercise on VPC:

· A VPC with a CIDR block of 10.0.0.0/16.
· One public subnet with a CIDR block of 10.0.1.0/24.
· One private subnet with a CIDR block of 10.0.2.0/24.
· One Internet Gateway.
· One public route table with a route to the Internet Gateway,
  and the correct association between the public subnet and the public route table.

Done => AWS lab performed for VPC Terraform

=> EC2 instance using our VPC Terraform
Done =>  AWS VPC Manual Lab 

=> Project (EC2+VPC+NGINX)
Project: VPC + EC2 + NGINX + HTTP Access:

· A VPC with pubic and private subnet
· A EC2 instance using public subnet we created.
· Setup nginx webserver
· Create security group rule to enable HTTP access
· Output the webserver URL on terminal

=> Lab done

=> Terraform Data Source

It allows you to fetch and use information from
· external sources or
· existing resources within your cloud infrastructure.

Useful for obtaining dynamic data that you need for our configurations.
Note:-> How to get the dynamic data from data source

=> Lab Done
# Note: It might occur charges so be wise

=> Data Source (VPC and SG)
=> Lab Done

=> EC2 create using data source

Data Source TASK:
=>Create an EC2 instance using existing
-VPC
-private-subnets
-security-group

=> Lab Done

=> Terraform Variable

environment var (least priority) => export TF_VAR_key=value => its use case in senseitive data dealing => Done
export TF_VAR_my_instance_type=t2.micro    ==> To set the environment variable in Mac/Linux
$env:TF_VAR_my_instance_type="t2.micro"    ==> To set the environment variable in Windows

terraform.tfvars (most priority)=> done
*.auto.tfvars    (most priority than above)=> done
-var & -var-file (most priority than above)=> Pass variables on the CLI with -var or -var-file =>
==> -var      => terraform apply -var "my_root_block_device={v_size=50, v_type=\""gp2\""}"
==> -var-file => terraform apply -var-file="terraform.tfvars"

Note:- Multi tagging lab pending


=> Local variable

Note:- {Terraform} => Its used when we want to deal with functionality not with providers

What are Terraform locals?
Local values (locals) are named values that you can use inside your Terraform configuration.
They are useful for avoiding repetition and making your code cleaner.
Unlike variables, locals cannot be overridden from command line or tfvars files. They are only for internal use.

Example:-

locals {
  service_name = "forum"
  owner        = "community-team"
  environment  = "production"
}

resource "aws_instance" "web" {
  ami           = "ami-12345678"
  instance_type = "t3.micro"

  tags = {
    Name        = local.service_name
    Owner       = local.owner
    Environment = local.environment
  }
}


=> Terraform operators & Expressions

Calculation

{Terraform} => Variable => locals => Output  

=> Terraform Function
Built-in functions that we can call from within expressions to transform and combine values.

{Terraform} => Variable => locals => Output

To find max number and min number, upper and lower case, startwith, split ,toset()(to remove duplicates), contains (), length() and join() etc....

Note:- {Terraform} => Its used when we want to deal with functionality not with providers


=> Terraform Multi-Resources

-> Count    => Lab done
-> for_each =>used with mapp or set and within mapp its using key & value for object. => Lab Done

=> Project (AWS IAM Mgt.)

Task: AWS IAM Management
· Provide user and roles info via YAML file
. Read the YAML file and process data
· Create IAM users
· Generate Passwords for the users
· Attach policy/roles to each users


The flatten function in Terraform is used to transform a list of lists into a single, flat list.

{ username = "raju", role = "AmazonEC2FullAccess" },
{ username = "sham", role = "AmazonS3ReadOn lyAccess" }


=> Terraform module


Tribhuvan terraform custome aws vpc module
https://registry.terraform.io/modules/tribhuvan357/vpc-test-module/aws/latest

Github tag command for terraform

git tag "v1.0.0"
git push --tags

=> Testing our module

Lab done 
Note:- add provider to the top of main.tf file where we keep module code
And then add required details in same main.tf file like vpc and subnet details and execute it normally


=> Terraform depends_on


Terraform usually figures out the correct order automatically (called implicit dependency).But sometimes Terraform cannot detect the dependency → then you use depends_on (called explicit dependency) to tell Terraform:
👉 “Wait for this resource before creating/destroying that resource.”

Implicit Dependency (Automatic) => 

resource "aws_vpc" "main" {
  cidr_block = "10.0.0.0/16"
}

resource "aws_subnet" "main" {
  vpc_id     = aws_vpc.main.id   # implicit dependency
  cidr_block = "10.0.1.0/24"
}

=> Here above, aws_subnet.main implicitly depends on aws_vpc.main because it uses its id.
Terraform knows it must create the VPC before the Subnet.

Explicit Dependency (Manual) => 

resource "aws_iam_role" "example" {
  name = "my-role"
}

resource "aws_iam_role_policy_attachment" "example" {
  role       = aws_iam_role.example.name
  policy_arn = "arn:aws:iam::aws:policy/AmazonS3FullAccess"

  depends_on = [aws_iam_role.example]   # explicit dependency
}

=> Here above "aws_iam_role_policy_attachment" is depends on "aws_iam_role" need to create first.



=> Terraform Resource lifecycle

Terraform resource lifecycle is about controlling how Terraform creates, updates, and destroys resources.
We define lifecycle rules inside a lifecycle { ... } block in a resource. This tells Terraform how to treat that resource during changes.

1️)create_before_destroy

Ensures a new resource is created before destroying the old one.

Useful when you want zero downtime.

📌 Example:

resource "aws_instance" "example" {
  ami           = "ami-123456"
  instance_type = "t2.micro"

  lifecycle {
    create_before_destroy = true
  }
}


➡ If you change ami, Terraform will:

Create a new instance.

Destroy the old one after the new one is ready.
(prevents downtime)

2️)prevent_destroy

Protects a resource from being accidentally destroyed.

Terraform will throw an error if you try to destroy it.

📌 Example:

resource "aws_s3_bucket" "important" {
  bucket = "my-production-bucket"

  lifecycle {
    prevent_destroy = true
  }
}


➡ Even if you run terraform destroy, this bucket won’t be deleted unless you remove the lifecycle rule.

3️)ignore_changes

Tells Terraform to ignore changes to specific attributes.

Useful when attributes are managed outside Terraform (like tags or passwords).

📌 Example:

resource "aws_instance" "example" {
  ami           = "ami-123456"
  instance_type = "t2.micro"
  tags = {
    Name = "server1"
  }

  lifecycle {
    ignore_changes = [tags]
  }
}


➡ If someone changes the tags in AWS console, Terraform won’t try to overwrite them.

4️)replace_triggered_by (Terraform v1.1+)

Forces recreation of a resource if another resource or attribute changes.

📌 Example:

resource "aws_instance" "example" {
  ami           = "ami-123456"
  instance_type = "t2.micro"

  lifecycle {
    replace_triggered_by = [
      aws_security_group.sg.id
    ]
  }
}


➡ If the security group changes, Terraform will destroy and re-create this instance.

🔹 Summary
Lifecycle Rule	            Purpose
create_before_destroy	Prevent downtime when replacing resources
prevent_destroy	        Protect important resources from deletion
ignore_changes	        Avoid Terraform overwriting manual changes
replace_triggered_by	Recreate a resource when another changes


✅ Best Practice

Use prevent_destroy for critical resources like S3 buckets, databases.
Use create_before_destroy for servers or load balancers where downtime is critical.
Use ignore_changes when external systems update resources.


=> Terraform validation (Pre-Conditions and Post-Conditions Resources)

Allow you to define checks that must be true before a resource is created (precondition) and after a resource is created (postcondition).




=> Terraform state modification

State manipulation 

· List all resources in the state:
o terraform state list

· Show details of a specific resource:
o terraform state show <resource_address>

· Move a resource to a different address:
o terraform state mv <source_address> <destination_address>

· Remove a resource from the state:
o terraform state rm <resource_address>

· Pull the current state:
o terraform state pull

· Push a local state file to the remote backend:
o terraform state push <state_file>

· List all state commands:
o terraform state


=> Terraform import command

Terraform import is a command in Terraform that allows you to import existing infrastructure resources into your Terraform state.


=> Terraform workspace

Allows you to manage multiple sets of infrastructure configurations within a single configuration directory.

Each workspace has its own state file	

tfstate                     tfstate                      tfstate

workspace-dev              workspace-test               workspace-prod


                            tf-config
							
							
							
							
· Listing Workspaces
o terraform workspace list

· Creating a Workspace
terraform workspace new <workspace_name>

· Selecting a Workspace
o terraform workspace select <workspace_name>

· Showing the Current Workspace
o terraform workspace show

· Deleting a Workspace
o terraform workspace select default
o terraform workspace delete <workspace_name>							
======================================================================================================================================							

=> Terraform Cloud 

Terraform Cloud is a managed service provided by HashiCorp that facilitates collaboration on Terraform configurations.

Providing features like
· remote state management,
· version control system (VCS) integration,
· automated runs, and
· secure variable management.







